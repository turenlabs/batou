package fpfilter

import (
	"strings"
	"testing"
)

// ---------------------------------------------------------------------------
// IsGeneratedFile
// ---------------------------------------------------------------------------

func TestIsGeneratedFile_PathPatterns(t *testing.T) {
	tests := []struct {
		path string
		want bool
	}{
		{"api/v1/service.pb.go", true},
		{"api/v1/service.pb.cc", true},
		{"internal/models_generated.go", true},
		{"internal/schema_gen.go", true},
		{"internal/schema.gen.go", true},
		{"internal/schema.gen.ts", true},
		{"Models.generated.cs", true},
		{"src/parser_generated.rs", true},
		{"node_modules/lodash/index.js", true},
		{"vendor/github.com/foo/bar.go", true},
		{"dist/bundle.js", true},
		{"build/output.js", true},
		{"src/__generated__/types.ts", true},
		{"src/generated/query.ts", true},
		{"assets/app.min.js", true},
		{"assets/style.min.css", true},
		{"assets/vendor.bundle.js", true},
		// Negative cases
		{"internal/scanner/scanner.go", false},
		{"cmd/gtss/main.go", false},
		{"src/app.ts", false},
		{"handler.py", false},
	}

	for _, tt := range tests {
		t.Run(tt.path, func(t *testing.T) {
			got := IsGeneratedFile(tt.path, "")
			if got != tt.want {
				t.Errorf("IsGeneratedFile(%q, \"\") = %v, want %v", tt.path, got, tt.want)
			}
		})
	}
}

func TestIsGeneratedFile_ContentMarkers(t *testing.T) {
	tests := []struct {
		name    string
		content string
		want    bool
	}{
		{
			name:    "Go generated header",
			content: "// Code generated by protoc-gen-go. DO NOT EDIT.\npackage api\n",
			want:    true,
		},
		{
			name:    "DO NOT EDIT standalone",
			content: "// DO NOT EDIT - this file is auto-generated\npackage models\n",
			want:    true,
		},
		{
			name:    "C-style block generated",
			content: "/* Code generated by tool */\n#include <stdio.h>\n",
			want:    true,
		},
		{
			name:    "@generated annotation",
			content: "// @generated\npackage foo\n",
			want:    true,
		},
		{
			name:    "auto-generated marker",
			content: "# auto-generated by schema compiler\nimport os\n",
			want:    true,
		},
		{
			name:    "Generated by marker",
			content: "// Generated by swagger codegen\npackage api\n",
			want:    true,
		},
		{
			name:    "This file is generated",
			content: "# This file is generated. Do not modify.\nFOO=bar\n",
			want:    true,
		},
		{
			name:    "This file was generated",
			content: "// This file was generated from schema.proto\npackage pb\n",
			want:    true,
		},
		{
			name:    "Normal source file",
			content: "package main\n\nfunc main() {\n\tfmt.Println(\"hello\")\n}\n",
			want:    false,
		},
		{
			name:    "Comment mentioning generation in non-marker way",
			content: "package main\n\n// This generates a new ID for the user\nfunc generateID() string { return \"abc\" }\n",
			want:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsGeneratedFile("src/foo.go", tt.content)
			if got != tt.want {
				t.Errorf("IsGeneratedFile(\"src/foo.go\", ...) = %v, want %v", got, tt.want)
			}
		})
	}
}

// ---------------------------------------------------------------------------
// IsCommentLine
// ---------------------------------------------------------------------------

func TestIsCommentLine(t *testing.T) {
	tests := []struct {
		line string
		want bool
	}{
		// Positive cases
		{"// this is a comment", true},
		{"  // indented comment", true},
		{"# python comment", true},
		{"  # indented hash comment", true},
		{"-- SQL comment", true},
		{"; ini comment", true},
		{"% LaTeX comment", true},
		{"/* block comment start */", true},
		{"* continuation of block comment", true},
		{"*\tcontinuation with tab", true},
		{"*/", true},
		{"<!-- HTML comment -->", true},
		{"REM batch comment", true},
		{"rem batch comment", true},
		// Negative cases
		{"func main() {", false},
		{"x = 42 // inline comment", false},
		{"import os", false},
		{"", false},
		{"   ", false},
	}

	for _, tt := range tests {
		t.Run(tt.line, func(t *testing.T) {
			got := IsCommentLine(tt.line)
			if got != tt.want {
				t.Errorf("IsCommentLine(%q) = %v, want %v", tt.line, got, tt.want)
			}
		})
	}
}

// ---------------------------------------------------------------------------
// InBlockComment
// ---------------------------------------------------------------------------

func TestInBlockComment_CStyle(t *testing.T) {
	code := `package main
/*
This is a block comment
with multiple lines
*/
func main() {}
`
	lines := strings.Split(code, "\n")
	result := InBlockComment(lines)

	// lines[0] = "package main"         -> false
	// lines[1] = "/*"                   -> true (opener at start)
	// lines[2] = "This is a block..."   -> true
	// lines[3] = "with multiple lines"  -> true
	// lines[4] = "*/"                   -> true (closer, still in block)
	// lines[5] = "func main() {}"       -> false
	expected := []bool{false, true, true, true, true, false}

	for i := 0; i < len(expected) && i < len(result); i++ {
		if result[i] != expected[i] {
			t.Errorf("line %d (%q): got %v, want %v", i, lines[i], result[i], expected[i])
		}
	}
}

func TestInBlockComment_HTML(t *testing.T) {
	code := `<div>
<!-- this is
a multi-line
HTML comment -->
<p>hello</p>
`
	lines := strings.Split(code, "\n")
	result := InBlockComment(lines)

	expected := []bool{false, true, true, true, false}
	for i := 0; i < len(expected) && i < len(result); i++ {
		if result[i] != expected[i] {
			t.Errorf("line %d (%q): got %v, want %v", i, lines[i], result[i], expected[i])
		}
	}
}

func TestInBlockComment_SingleLineBlock(t *testing.T) {
	code := `/* single line block comment */
func main() {}
`
	lines := strings.Split(code, "\n")
	result := InBlockComment(lines)

	// line 0: "/* single line block comment */" -> true (opens and closes, opener at start)
	// line 1: "func main() {}" -> false
	if !result[0] {
		t.Error("expected single-line block comment to be marked as comment")
	}
	if result[1] {
		t.Error("expected line after single-line block comment to not be marked")
	}
}

func TestInBlockComment_InlineBlockNotAtStart(t *testing.T) {
	code := `x = foo /* inline comment */ + bar
y = 42
`
	lines := strings.Split(code, "\n")
	result := InBlockComment(lines)

	// line 0: "x = foo /* inline comment */ + bar" -> false (opener not at pos 0)
	// line 1: "y = 42" -> false
	if result[0] {
		t.Error("inline block comment not at line start should not mark full line")
	}
	if result[1] {
		t.Error("line after inline block comment should not be marked")
	}
}

// ---------------------------------------------------------------------------
// IsTestFile
// ---------------------------------------------------------------------------

func TestIsTestFile(t *testing.T) {
	tests := []struct {
		path string
		want bool
	}{
		// Test file suffixes
		{"internal/scanner/scanner_test.go", true},
		{"tests/test_handler.py", true},
		{"src/app.test.js", true},
		{"src/app.test.tsx", true},
		{"src/app.spec.ts", true},
		{"spec/models/user_spec.rb", true},
		{"test/integration_test.java", true},
		{"handler_test.c", true},
		{"parser_test.rs", true},

		// Test directory segments
		{"test/handler.go", true},
		{"tests/conftest.py", true},
		{"testdata/fixtures/go/vuln.go", true},
		{"fixtures/vulnerable/injection.py", true},
		{"__tests__/app.js", true},
		{"spec/helper.rb", true},
		{"__mocks__/api.js", true},
		{"__fixtures__/data.json", true},
		{"testing/helpers.go", true},
		{"test_data/sample.txt", true},

		// Exact filenames
		{"tests/conftest.py", true},

		// Test prefix pattern
		{"test_utils.py", true},
		{"tests/test_auth.py", true},

		// Keywords
		{"internal/mock_client.go", true},
		{"src/fake_service.ts", true},
		{"lib/stub_handler.rb", true},
		{"docs/example_usage.py", true},

		// Maven/Gradle test conventions
		{"src/test/java/org/owasp/webgoat/SomeTest.java", true},
		{"src/it/java/org/owasp/webgoat/IntegrationTest.java", true},
		{"src/test/resources/config.xml", true},

		// Java test class suffixes (case-sensitive)
		{"src/main/java/FooTest.java", true},
		{"src/main/java/FooIT.java", true},
		{"src/main/java/FooITCase.java", true},
		{"src/main/java/BarTests.java", true},

		// Test config files
		{"cypress.config.ts", true},
		{"playwright.config.js", true},

		// Negative cases
		{"/app/handler.go", false},
		{"internal/scanner/scanner.go", false},
		{"cmd/gtss/main.go", false},
		{"src/index.ts", false},
		{"lib/auth.rb", false},
		{"api/controller.java", false},
		// Java files that look like tests but aren't
		{"src/main/java/TestUtils.java", false},
		{"src/main/java/Contest.java", false},
	}

	for _, tt := range tests {
		t.Run(tt.path, func(t *testing.T) {
			got := IsTestFile(tt.path)
			if got != tt.want {
				t.Errorf("IsTestFile(%q) = %v, want %v", tt.path, got, tt.want)
			}
		})
	}
}

// ---------------------------------------------------------------------------
// IsVendoredLibrary
// ---------------------------------------------------------------------------

func TestIsVendoredLibrary(t *testing.T) {
	tests := []struct {
		path string
		want bool
	}{
		// Known JS library prefixes
		{"frontend/src/assets/jquery-3.6.0.js", true},
		{"static/js/backbone-min.js", true},
		{"public/underscore-1.13.js", true},
		{"assets/three.js", true},
		{"lib/ace.js", true},
		{"vendor/wysihtml5-0.3.0.js", true},
		{"static/bootstrap.min.js", true},
		{"js/codemirror-5.65.js", true},
		{"js/handlebars-4.7.js", true},
		{"static/socket.io-client.js", true},

		// Vendored directory patterns
		{"frontend/src/assets/private/RenderPass.js", true},
		{"public/static/vendor/moment.js", true},
		{"lib/third_party/parser.js", true},
		{"src/3rdparty/crypto.js", true},
		{"src/external/helper.js", true},
		{"data/static/codefixes/sqli_fix.ts", true},

		// Negative cases â€” application JS files should NOT match
		{"src/app.js", false},
		{"routes/handler.js", false},
		{"frontend/src/app/login.component.ts", false},
		{"lib/insecurity.ts", false},
		{"src/services/auth.service.ts", false},

		// Non-JS files with vendor-like names should NOT match prefix list
		{"src/jquery-wrapper.ts", false},
		{"internal/bootstrap.go", false},

		// But non-JS in vendored dirs still match
		{"frontend/src/assets/private/shader.glsl", true},
		{"data/static/codefixes/login_fix.java", true},
	}

	for _, tt := range tests {
		t.Run(tt.path, func(t *testing.T) {
			got := IsVendoredLibrary(tt.path)
			if got != tt.want {
				t.Errorf("IsVendoredLibrary(%q) = %v, want %v", tt.path, got, tt.want)
			}
		})
	}
}

// ---------------------------------------------------------------------------
// Edge cases
// ---------------------------------------------------------------------------

func TestIsGeneratedFile_EmptyInputs(t *testing.T) {
	if IsGeneratedFile("", "") {
		t.Error("empty path and content should not be generated")
	}
}

func TestIsCommentLine_EmptyAndWhitespace(t *testing.T) {
	if IsCommentLine("") {
		t.Error("empty line should not be a comment")
	}
	if IsCommentLine("   \t  ") {
		t.Error("whitespace-only line should not be a comment")
	}
}

func TestInBlockComment_Empty(t *testing.T) {
	result := InBlockComment(nil)
	if len(result) != 0 {
		t.Error("nil input should return empty result")
	}
	result = InBlockComment([]string{})
	if len(result) != 0 {
		t.Error("empty input should return empty result")
	}
}

func TestIsTestFile_EmptyPath(t *testing.T) {
	if IsTestFile("") {
		t.Error("empty path should not be a test file")
	}
}

func TestIsGeneratedFile_LargeContent(t *testing.T) {
	// Marker at the very start of a large file
	content := "// Code generated by tool\n" + strings.Repeat("x := 1\n", 10000)
	if !IsGeneratedFile("big.go", content) {
		t.Error("generated marker at start of large file should be detected")
	}

	// Marker well past the 2KB header cutoff should NOT be detected
	content = strings.Repeat("x := 1\n", 1000) + "// Code generated by tool\n"
	if IsGeneratedFile("big.go", content) {
		t.Error("generated marker past 2KB should not be detected")
	}
}
