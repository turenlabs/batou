// Package fpfilter provides false-positive filtering helpers used across
// the scanner and individual rule packages.  All functions are pure
// (no side effects) and safe for concurrent use.
package fpfilter

import (
	"path/filepath"
	"strings"
)

// ---------------------------------------------------------------------------
// Generated code detection
// ---------------------------------------------------------------------------

// generatedMarkers are strings that, when found in the first few lines of a
// file, indicate the file was auto-generated and should be skipped.
var generatedMarkers = []string{
	"// Code generated",
	"// DO NOT EDIT",
	"/* Code generated",
	"/* DO NOT EDIT",
	"# Code generated",
	"# DO NOT EDIT",
	"@generated",
	"auto-generated",
	"AUTO-GENERATED",
	"autogenerated",
	"AUTOGENERATED",
	"This file is generated",
	"This file was generated",
	"Generated by",
	"generated by",
}

// generatedPathPatterns are path substrings/suffixes that indicate generated
// files or vendored dependencies.
var generatedPathPatterns = []string{
	".pb.go",
	".pb.cc",
	".pb.h",
	"_generated.go",
	"_gen.go",
	".gen.go",
	".gen.ts",
	".generated.cs",
	"_generated.rs",
	"/node_modules/",
	"/vendor/",
	"/dist/",
	"/build/",
	"/__generated__/",
	"/generated/",
	".min.js",
	".min.css",
	".bundle.js",
}

// IsGeneratedFile returns true if the file at filePath with the given content
// looks like it was auto-generated or is vendored/third-party code.
// content may be empty; in that case only the path is checked.
func IsGeneratedFile(filePath string, content string) bool {
	// Normalise path separators for cross-platform matching.
	// Prepend "/" so patterns like "/vendor/" also match relative paths
	// that start with "vendor/".
	norm := "/" + filepath.ToSlash(filePath)

	for _, pat := range generatedPathPatterns {
		if strings.Contains(norm, pat) {
			return true
		}
	}

	// Check the first 2 KB (or first ~40 lines) for marker strings.
	header := content
	if len(header) > 2048 {
		header = header[:2048]
	}
	lower := strings.ToLower(header)
	for _, marker := range generatedMarkers {
		if strings.Contains(lower, strings.ToLower(marker)) {
			return true
		}
	}

	return false
}

// ---------------------------------------------------------------------------
// Comment detection
// ---------------------------------------------------------------------------

// IsCommentLine returns true if the trimmed line starts with a single-line or
// block-comment introducer in any of the supported languages.
func IsCommentLine(line string) bool {
	trimmed := strings.TrimSpace(line)
	if trimmed == "" {
		return false
	}
	return strings.HasPrefix(trimmed, "//") ||
		strings.HasPrefix(trimmed, "#") ||
		strings.HasPrefix(trimmed, "--") ||
		strings.HasPrefix(trimmed, ";") ||
		strings.HasPrefix(trimmed, "%") ||
		strings.HasPrefix(trimmed, "/*") ||
		strings.HasPrefix(trimmed, "* ") ||
		strings.HasPrefix(trimmed, "*\t") ||
		trimmed == "*" ||
		strings.HasPrefix(trimmed, "*/") ||
		strings.HasPrefix(trimmed, "<!--") ||
		strings.HasPrefix(trimmed, "REM ") ||
		strings.HasPrefix(trimmed, "rem ")
}

// InBlockComment tracks whether a given line index falls inside a multi-line
// block comment. It does a single pass over all lines, tracking nesting for
// /* ... */ and <!-- ... --> style comments.
//
// The returned slice has the same length as lines; result[i] is true when
// line i is entirely inside a block comment.
func InBlockComment(lines []string) []bool {
	n := len(lines)
	result := make([]bool, n)
	inBlock := false

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)

		if inBlock {
			result[i] = true
			// Check if block comment ends on this line.
			if strings.Contains(trimmed, "*/") || strings.Contains(trimmed, "-->") {
				inBlock = false
			}
			continue
		}

		// Not currently in a block comment.
		// Check if a block comment opens on this line.
		if openIdx := blockCommentOpen(trimmed); openIdx >= 0 {
			// If the line also closes on the same line, it is a single-line block comment
			// (e.g.  /* foo */ ).  Mark it as a comment line only if nothing
			// meaningful precedes the opening marker.
			closeIdx := blockCommentClose(trimmed[openIdx:])
			if closeIdx >= 0 {
				// Single-line block comment; only mark as comment if the
				// opener is at the start (after whitespace).
				if openIdx == 0 {
					result[i] = true
				}
			} else {
				// Block comment continues to subsequent lines.
				if openIdx == 0 {
					result[i] = true
				}
				inBlock = true
			}
		}
	}

	return result
}

// blockCommentOpen returns the index of the first block-comment opener in
// the trimmed line, or -1 if none found.
func blockCommentOpen(trimmed string) int {
	idx := -1
	for _, opener := range []string{"/*", "<!--", `"""`} {
		if i := strings.Index(trimmed, opener); i >= 0 {
			if idx < 0 || i < idx {
				idx = i
			}
		}
	}
	return idx
}

// blockCommentClose returns the index of the first block-comment closer
// after the opener, or -1 if none.
func blockCommentClose(s string) int {
	// Skip past the opener itself.
	for _, pair := range []struct{ open, close string }{
		{"/*", "*/"},
		{"<!--", "-->"},
		{`"""`, `"""`},
	} {
		if strings.HasPrefix(s, pair.open) {
			rest := s[len(pair.open):]
			if idx := strings.Index(rest, pair.close); idx >= 0 {
				return idx
			}
		}
	}
	return -1
}

// ---------------------------------------------------------------------------
// Test file detection
// ---------------------------------------------------------------------------

// testDirSegments are directory names that indicate test code.
var testDirSegments = []string{
	"/test/",
	"/tests/",
	"/testdata/",
	"/fixtures/",
	"/fixture/",
	"/__tests__/",
	"/spec/",
	"/__mocks__/",
	"/__fixtures__/",
	"/testing/",
	"/test_data/",
	"/src/test/",  // Maven/Gradle convention
	"/src/it/",    // Maven integration tests
}

// testFileSuffixes are filename suffixes that indicate test files.
var testFileSuffixes = []string{
	"_test.go",
	"_test.py",
	"_test.rb",
	"_test.rs",
	"_test.c",
	"_test.cpp",
	"_test.java",
	"_test.cs",
	".test.js",
	".test.jsx",
	".test.ts",
	".test.tsx",
	".test.mjs",
	".spec.js",
	".spec.jsx",
	".spec.ts",
	".spec.tsx",
	".spec.rb",
	"_spec.rb",
}

// javaTestSuffixes match Java/Kotlin conventional test class names.
var javaTestSuffixes = []string{
	"Test.java",
	"Tests.java",
	"IT.java",        // integration tests
	"ITCase.java",
	"Spec.java",
	"Test.kt",
	"Tests.kt",
	"IT.kt",
}

// testFileNames are exact base filenames that indicate test/config files.
var testFileNames = []string{
	"conftest.py",
	"setup_test.go",
	"cypress.config.ts",
	"cypress.config.js",
	"playwright.config.ts",
	"playwright.config.js",
}

// vendoredJSLibPrefixes are filename prefixes for well-known third-party JS
// libraries that should be treated as generated/vendored code.
var vendoredJSLibPrefixes = []string{
	"jquery",
	"backbone",
	"underscore",
	"lodash",
	"moment",
	"angular.",   // Angular 1.x vendored builds
	"react.",     // vendored React builds
	"vue.",       // vendored Vue builds
	"bootstrap",
	"d3.",
	"three.",
	"ace.",
	"codemirror",
	"highlight",
	"prism",
	"wysihtml",
	"ckeditor",
	"tinymce",
	"quill",
	"popper",
	"chart.",
	"raphael",
	"ember",
	"knockout",
	"mootools",
	"prototype.",
	"dojo",
	"ext-all",
	"handlebars",
	"mustache",
	"require.",
	"modernizr",
	"socket.io",
}

// vendoredDirPatterns are path substrings for directories containing
// third-party or educational/challenge code that is not production code.
var vendoredDirPatterns = []string{
	"/assets/private/",
	"/static/vendor/",
	"/third_party/",
	"/3rdparty/",
	"/external/",
	"/codefixes/",    // intentionally vulnerable challenge snippets
	"/codefix/",
	"/snippets/challenge/",
}

// testPathKeywords are case-insensitive substrings that indicate test-like files.
var testPathKeywords = []string{
	"mock",
	"fake",
	"stub",
	"example",
}

// IsTestFile returns true if the file path looks like a test, fixture, mock,
// or example file.
func IsTestFile(filePath string) bool {
	norm := filepath.ToSlash(filePath)
	// Prepend "/" so patterns like "/test/" also match relative paths
	// that start with "test/".
	lower := strings.ToLower("/" + norm)

	// Directory segments.
	for _, seg := range testDirSegments {
		if strings.Contains(lower, seg) {
			return true
		}
	}

	// File suffixes.
	for _, suf := range testFileSuffixes {
		if strings.HasSuffix(lower, suf) {
			return true
		}
	}

	// Java/Kotlin conventional test class suffixes (case-sensitive).
	base := filepath.Base(filePath)
	for _, suf := range javaTestSuffixes {
		if strings.HasSuffix(base, suf) {
			return true
		}
	}

	// Exact base filenames.
	baseLower := strings.ToLower(base)
	for _, name := range testFileNames {
		if baseLower == name {
			return true
		}
	}

	// Test file name patterns: test_*.py
	if strings.HasPrefix(baseLower, "test_") && strings.HasSuffix(baseLower, ".py") {
		return true
	}

	// Keywords in the path.
	for _, kw := range testPathKeywords {
		if strings.Contains(lower, kw) {
			return true
		}
	}

	return false
}

// ---------------------------------------------------------------------------
// Vendored / third-party library detection
// ---------------------------------------------------------------------------

// IsVendoredLibrary returns true if the file looks like a known third-party
// JavaScript library or lives in a vendored/third-party directory.
// These files produce noise because they contain patterns (eval, innerHTML, etc.)
// that are intentional library internals, not application vulnerabilities.
func IsVendoredLibrary(filePath string) bool {
	norm := "/" + filepath.ToSlash(filePath)
	lower := strings.ToLower(norm)

	// Check vendored directory patterns.
	for _, pat := range vendoredDirPatterns {
		if strings.Contains(lower, pat) {
			return true
		}
	}

	// Check known JS library filenames (only for .js files).
	ext := strings.ToLower(filepath.Ext(filePath))
	if ext == ".js" {
		baseLower := strings.ToLower(filepath.Base(filePath))
		for _, prefix := range vendoredJSLibPrefixes {
			if strings.HasPrefix(baseLower, prefix) {
				return true
			}
		}
	}

	return false
}
